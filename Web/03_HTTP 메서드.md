# HTTP 메서드

- HTTP API 를 만들어보자
- HTTP 메서드 - GET, POST
- HTTP 메서드 - PUT, PATCH, DELETE
- HTTP 메서드의 속성



***



### HTTP API 를 만들어보자

> 요구사항
>
> - 회원 목록 조회
> - 회원 조회
> - 회원 등록
> - 회원 수정
> - 회원 삭제



#### API URI 설계

> URI (**U**niform **R**esource **I**dentifier)
>
> - 회원 목록 조회 /read-member-list
> - 회원 조회 /read-member-by-id
> - 회원 수정 /update-member
> - 회원 삭제 /delete-member

> 이것은 좋은 URI일까..?
>
> 가장 중요한 것은 **리소스 식별** (진짜 중요!!)



#### API URI 고민

- 리소스의 의미는 뭘까?

> - 회원을 등록하고 수정하고 조회하는게 리소스가 아니다!!
>
> - ex) 미네랄을 캐라 → 미네랄이 리소스
> - **"회원"이라는 개념 자체가 바로 리소스**

- 리소스를 어떻게 식별하는게 좋을까?

> - 회원을 등록하고 수정하고 조회하는 것을 모두 배제
>
> - **회원이라는 리소스만 식별하면 된다 → 회원 리소스를 URI 에 매핑**



#### API URI 설계 (리소스에 대한 고민 이후)

- **회원** 목록 조회 /members
- **회원** 조회 /members/{id} 
- **회원** 수정 /members/{id}
- **회원** 삭제 /members/{id}

> 참고 : 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장 (member → members)

> 위에서 문제 : /members/{id} 끼리 어떻게 구분하지..?



#### 리소스와 행위를 분리

> 가장 중요한 것은 리소스를 식별하는 것

- **URI는 리소스만 식별!**
- **리소스**와 해당 리소스를 대사으로 하는 **행위**를 분리

> - 리소스 : 회원
> - 행위 : 조회, 등록, 삭제, 변경

- 리소스는 명사, 행위는 동사
- 행위(메서드)는 어떻게 구분?

> **HTTP 메서드가 이 역할을 해줌!**



***



### HTTP 메서드 - GET, POST

> HTTP 메서드는 **클라이언트가 서버에게 요청을 할 때 기대하는 행동**

**[주요 메서드 종류]**

- GET: 리소스 조회
- POST: 요청 데이터 처리, 주로 등록에 사용
- PUT: 리소스를 대체, 해당 리소스가 없으면 생성 (덮어씌운다 생각하면 될듯)
- PATCH: 리소스 부분 변경 
- DELETE: 리소스 삭제 

**[기타 메서드 종류]**

- HEAD: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환 (HTTP 메시지에서 바디 빼고 헤더까지만 줘)
- OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명 (주로 CORS에서 사용) (참고)
- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정 (거의 X)
- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행 (거의 X)



### GET

- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음



**[리소스 조회]**

- 클라이언트가 메시지 전달

>  GET /members/100 HTTP/1.1
>
> Host: localhost:8080

- 서버 도착

> 서버에서 /members/100 데이터 조회
>
> {
>
> ​	"username": "young",
>
> ​	"age": 20
>
> }

- 서버에서 응답 메시지를 만들어 클라이언트에게 전달

> HTTP/1.1 200 OK
>
> Content-Type: application/json
>
> Content-Length: 34
>
>  
>
> {
>
> ​	"username": "young",
>
> ​	"age": 20
>
> }



#### POST

- 요청 데이터(클라이언트 → 서버)를 처리
- **메시지 바디를 통해 서버로 요청 데이터 전달** (처리해줘!)
- 서버는 요청 데이터를 **처리**

> 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다

- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용



**[리소스 등록]**

- 클라이언트가 메시지 전달

> POST /members HTTP/1.1
>
> Content-Type: application/json
>
>  
>
> {
>
> ​	"username": "young",
>
> ​	"age": 20
>
> }

> 이때 클라이언트와 서버는 서로 약속을 하는데 위 예시로 설명하자면
>
> /members 로 POST로 보내면, 이 데이터는 (저장할거야, 내부적인 프로세스에 쓸거야 등등) 약속을 함

- 서버에 도착
- 서버가 신규 리소스 생성

> /members → /members/100 (신규 리소스 식별자 생성)
>
> {
>
> ​	"username": "young",
>
> ​	"age": 20
>
> }

- 서버가 응답데이터 전송

> HTTP/1.1 201 Created
>
> Content-Type: application/json
>
> Content-Length: 34
>
> Location: /members/100 (자원이 신규 생성된 URI  경로도 보내줌)
>
>  
>
> {
>
> ​	"username": "young",
>
> ​	"age": 20
>
> }



**[요청 데이터를 어떻게 처리한다는 뜻일까? 예시]**

- 스펙: POST 메서드는 **대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청**합니다.
- 예를 들어 POST는 다음과 같은 기능에 사용됩니다.

> - HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공
>
> > ex) HTML FORM에 입력한 정보로 회원 가입, 주문 등에서 사용
>
> - 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시
>
> > ex) 게시판 글쓰기, 댓글 달기
>
> - 서버가 아직 식별하지 않은 새 리소스 생성
>
> > ex) 신규 주문 생성
>
> - 기존 자원에 데이터 추가
>
> > ex) 한 문서 끝에 내용 추가하기

- **정리: 이 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야함 → 정해진 것이 없음**



**[POST 정리]**

1. 새 리소스 생성 (등록)

> - 서버가 아직 식별하지 않은 새 리소스 생성

2. **요청 데이터 처리**

> - 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우
>
> > ex) 주문에서 결제 완료 → 배달 시작 → 배달 완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
>
> - POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음
>
> > ex) POST /orders/{orderId}/start-delivery 
> >
> > (**컨트롤 URI** : 기본적으로 리소스 단위로 설계해야하지만 리소스 단위만으로는 설계하기 힘든 경우가 있음. 그런 경우에 사용)

3. 다른 메서드로 처리하기 애매한 경우

> - ex) JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우
> - 애매하면 POST



***



### HTTP 메서드 - PUT, PATCH, DELETE

> HTTP 메서드는 **클라이언트가 서버에게 요청을 할 때 기대하는 행동**

### PUT

> PUT /members/100 HTTP/1.1
>
> Content-Type: application/json
>
>  
>
> {
>
> ​	"username": "hello",
>
> ​	"age": 20
>
> }

- 리소스를 대체 (폴더에 파일을 넣는거랑 비슷)

> - 리소스가 있으면 (완전히) 대체 
> - 리소스가 없으면 생성
> - 쉽게 이야기해서 덮어버림

- **중요! 클라이언트가 리소스를 식별 **(POST와의 큰 차이점)

> PUT **/members/100** HTTP/1.1 클라이언트가 이미 리소스의 위치를 알고있음

> - 클라이언트가 리소스 위치를 알고 URI 지정
> - POST와 차이점



**[PUT -  리소스가 있는 경우]**

- 클라이언트가 보냄

> PUT /members/100 HTTP/1.1
>
> Content-Type: application/json
>
>  
>
> {
>
> ​	"username": "old",
>
> ​	"age": 50
>
> }

> (서버)

>/members/100
>
>{
>
>​	"username": "young",
>
>​	"age": 20
>
>}

- 서버가 받았는데 이미 무언가가 저장되어있음
- 클라이언트로부터 받은 정보로 대체해버림

>(서버)
>
>/members/100
>
>{
>
>​	"username": "old",
>
>​	"age": 50
>
>}

**[주의! 리소스를 완전히 대체한다]**

- 클라이언트가 아래와같이 보냄

> PUT /members/100 HTTP/1.1
>
> Content-Type: application/json
> 
>
> {
>
> ​	"age": 50
>
> }

> (서버)

>/members/100
>
>{
>
>​	"username": "young",
>
>​	"age": 20
>
>}

- 서버가 메시지를 받음
- 메시지 내용으로 **완전히** 대체!

> (서버)

>/members/100
>
>{
>
>​	"age": 20
>
>}

> username 필드가 아예 삭제됨





#### PATCH

> 위의 PUT의  **[주의! 리소스를 완전히 대체한다]** 부분의 문제점을 해결할 수 있음
>
> **리소스 부분 변경**



**[리소스 부분 변경]**

- 클라이언트가 아래와같이 보냄

> PATCH /members/100 HTTP/1.1
>
> Content-Type: application/json
> 
> 
>
> {
>
> ​	"age": 50
>
> }

> (서버)

>/members/100
>
>{
>
>​	"username": "young",
>
>​	"age": 20
>
>}

- 서버가 메시지를 받음
- 메시지 내용으로 리소스를 **부분 변경**

> (서버)

>/members/100
>
>{
>
>​	"username": "young"
>
>​	"age": 20
>
>}





#### DELETE

> 리소스 제거



**[리소스 제거]**

- 클라이언트가 아래 메시지 보냄

> DELETE /members/100 HTTP/1.1
>
> Content-Type: application/json
>
> ​	

> (서버)

>/members/100
>
>{
>
>​	"username": "young",
>
>​	"age": 20
>
>}

- 서버에서 받은 후 해당 위치의 리소스를 **삭제** 



***



### HTTP 메서드의 속성

- 안전(Safe Methods)
- 멱등(Idempotent Methods)
- 캐시가능(Cacheable Methods)



#### 안전 (Safe)

> GET, HEAD, OPTIONS, TRACE

-  호출해도 리소스를 변경하지 않는다
- Q&A

> - **Q: 그래도 계속 호출해서, 로그같은게 쌓여 장애가 발생하면?**
> - **A: 안전은 해당 리소스만 고려! 그런 부분까지 고려하지 않는다.**



#### 멱등 (Idempotent)

- f(f(x)) = f(x)
- 한 번 호출하든 두번 호출하든 100번 호출하든 결과가 똑같다.
- 멱등 메서드

> GET: 한번 조회하든, 두번 조회하든 같은 결과가 조회된다.
>
> PUT: 결과를 대체한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다.
>
> DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 똑같다.
>
> **POST**: 멱등이 아니다! 두번 호출하면 같은 결제가 중복해서 발생할 수 있다

- 활용

> - 자동 복구 메커니즘
>
> > ex) DELETE를 보냈는데 삭제가 됐는지 잘 모르겠음. 그럼 또 DELETE를 보내면 됨. **Why? DELETE는 멱등하기때문에!**
>
> - 서버가 TIMEOUT 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가? 판단의 근거

- Q&A

> - **Q: 재요청 중간에 다른 곳에서 리소스를 변경해버리면??**
>
> > - 사용자1 : GET → username: A, age: 20
> > - 사용자2 : PUT → username: A, age: 30
> > - 사용자1 : GET → username: A, age: 30 (사용자 2로 인해 바뀐 데이터 조회)
>
> - **A: 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다**



#### 캐시가능 (Cacheable)

- 응답 결과 리소스를 캐시해서 사용해도 되는가?

> 예를 들어 웹페이지에 용량이 큰 이미지를 사용했는데 매번 불러오기 부담되니까 로컬PC 웹브라우저에 저장해놓음 = 캐시

- GET, HEAD, POST, PATCH 캐시 가능
- 실제로는 GET, HEAD 정도만 캐시로 이용

> - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음



