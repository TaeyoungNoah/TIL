# 객체지향프로그래밍2

### 상속

> 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

**[장점]**

1. 코드의 추가 및 변경이 매우 용이
2. 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여

```java
Class Parent{
  int age;
  // 조상 클래스
}
Class Child extends Parent {
  // 자손 클래스
}
```

> `Class`  +  `자손 클래스`  +  `extends`   +  `조상 클래스` 로 선언
>
> > 조상 클래스 : 부모(parent) 클래스, 상위(super) 클래스, 기반(base) 클래스
> >
> > 자손 클래스 : 자식(child) 클래스, 하위(sub) 클래스, 파생된(derived) 클래스

> `Child` 클래스는 `Parent` 클래스의 멤버를 모두 포함하고 있다.
>
> 위 경우에서는 `Child` 클래스에서 `age` 라는 멤버변수를 선언하지 않았지만 
>
> `Parent` 클래스를 상속했기때문에 `age` 라는 멤버면수를 가지고 있다.

***'조상 클래스가 변경되면 자손 클래스는 자동적으로 영향을 받게 되지만,***

***자손 클래스가 변경되는 것은 조상 클래스에 아무런 영향을 주지 못한다!'***

> 생성자와 초기화 블럭은 상속되지 않는다. **멤버만 상속된다.**
>
> 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

```java
Class Parent{
  int age;
  // 조상 클래스
}
Class Child1 extends Parent {
  // 자손 클래스1
}
Class Child2 extends Parent{
  // 자손 클래스2
}
```

> 위 예시에서 `Child1` 과 `Child2` 는 서로 같은 조상으로부터 상속되었지만 둘 사이에는 어떠한 관계도 없다. **'형제관계 같은 것은 없다!'**



**[클래스간의 관계]** (상속 vs 포함)

> 상속 (is a) : 원은 점**이다**. (Circle **is a** Point)
>
> 포함 (has a) : 원은 점을 **가지고 있다**. (Circle **has a** Point)
>
> > 위 경우에서 '포함' 쪽이 조금 더 적합한게 문장에서도 느껴진다.
> >
> > 이렇게 **'is a'** or **'has a'** 를 이용하여 클래스간의 관계를 **적절하게** 결정해야 한다.
> >
> > (가능한 많은 관계를 맺도록 노력해야한다!!)



Java는 다중상속을 허용하지 않는다. (클래스간의 관계를 더 명확히 하고, 코드의 신뢰성 상승)

```java
class Tv{
  boolean power;
  int channel;
  
  void power(){	power=!power;	}
  void channelUp(){	++channel;	}
  void channelDown(){	--channel;	}
}

class VCR{
	void play(){//...}
  void stop(){//...}
}

class TVCR extends TV{
  VCR vcr = new VCR();
  
  void play(){
    vcr.play;
  }
  void stop(){
    vcr.stop;
  }
}
```

> TVCR은 TV와 VCR의 속성 모두를 상속받고 싶었으나 Java에서는 다중상속을 허용하지 않으므로
>
> 위와같이 TV를 상속받고 VCR은 포함시켜 사용하면 원하던 효과를 누릴 수 있다.



***

### package와 import

**패키지(package)**

> 클래스&인터페이스의 묶음
>
> > 관련된 클래스끼리 묶어 더 효율적인 관리 가능

> - 하나의 소스파일에는 첫번째 문장으로 **단 한번**의 패키지 선언만을 허용
> - 모든 클래스는 반드시 하나의 패키지 속에 속해야 함
> - 패키지는 점(.)을 구분자로 하여 계층구조로 구성 가능
> - 패키지는 물리적으로 클래스파일(.class)을 포함하는 하나의 디렉토리



```java
package 패키지명;
```

> 위와같이 선언하며, 패키지 선언은
>
> 반드시 소스파일에서 주석과 공백을 제외한 첫번째 문장
>
> 하나의 소스파일에 단 한번만 선언 가능
>
> 패키지명은 **소문자로 하는 것을 원칙**으로 하고있음. (클래스명과 구분하기 위해)



**import문**

> 소스코드를 사용할때 다른 패키지의 클래스를 사용하려면
>
> 패키지명이 포함된 클래스 이름을 사용해야한다.
>
> 이때, `import` 를 이용하면 위 과정을 생략할 수 있다.

일반적인 소스파일의 구성

1. `pakage` 문
2. `import` 문
3. `class` 선언

```java
import 패키지명.클래스명;
//or
import 패키지명.*;
// 이때 *은 패키지 안에있는 모든 클래스를 패키지명 없이 사용 가능하게 해줌
// 실행시 성능차이가 전혀없음!!!!
```

```java
java.util.Data today = new java.util.Data();
// 로 작성해야 할 코드가

import java.util.Data;
Data today = new Data();
// 로 간단하게 작성이 가능하다
```



**static import문**

> `static import` 문을 이용하면 static 멤버를 호출할 때 클래스 이름을 생략 가능

```java
System.out.println(Math.random());
// 위 코드를

import static java.lang.Math.random;
System.out.println(random());
// 로 간단하게 작성 가능
```



***

### 제어자(modifier)

> 클래스, 변수, 메서드의 선어누에 함께 사용되어 부가적이 의미를 부여
>
> 접근 제어자 : public, protected, default, private 
>
> > **한 번에 하나**만 선택해서 사용
>
> 그           외 : static, final, abstract, native, transient, synchronized, volatile, stricffp
>
> > **하나의 대상에 여러가지 제어자를 조합**하여 사용하는 것이 가능



**static**

> **사용되는 곳: 멤버변수, 메서드, 초기화 블럭**

**final**

> `final` 이 앞에 붙으면 뒤에 오는 것이 변경 불가능해짐
>
> **사용되는 곳: 클래스, 메서드, 멤버변수,  지역변수**

**abstract**

> 추상 메서드나 추상 클래스를 만들때 쓰임
>
> **사용되는 곳: 클래스, 메서드**



**접근제어자**

> **사용되는 곳: 클래스, 맴버변수, 메서드, 생성자**

|  제어자   | 같은 클래스 | 같은 패키지 | 자손클래스 | 전 체 |
| :-------: | :---------: | :---------: | :--------: | :---: |
|  public   |      O      |      O      |     O      |   O   |
| protected |      O      |      O      |     O      |       |
| (default) |      O      |      O      |            |       |
|  private  |      O      |             |            |       |



**캡슐화**

```java
public class Time{
  private int hour;
  private int minute;
  private int second;
  
  public int getHour() {return hour;}
  public void setHour(int hour){
    if (hour<0 || hour>23) return; 
    // 위 코드를 통해 제대로 되지 않은 시간정보를 거를 수 있음
    this.hour=hour;
  }
}
```

> 위 처럼 멤버변수를 `private` 으로 두고 이를 확인하거나 설정하는 것을 클래스 내부의 메서드를 통해 구현하면 멤버변수를 보호할 수 있음



***

### 다형성

> **조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다**

 
