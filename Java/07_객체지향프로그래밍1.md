# 객체지향프로그래밍1

### 객체지향언어

##### [장점]

1. 코드의 재사용성이 높다

> 새로운 코드 작성시 기존 코드를 이용하여 쉽게 작성 가능

2. 코드의 관리가 용이하다.

> 코드 변경시 코드의 관계를 이용하여 쉽게 가능

3. 신뢰성이 높은 프로그래밍을 가능하게 한다.

> 제어자와 메서드를 이용하여 데이터 보호&올바른 값을 유지
>
> 코드의 중복을 제거하여 코드의 불일치로 인한 오작동 방지



***



### 클래스&객체

##### [클래스]

> 정의: 클래스란 객체를 **정의해 놓은 것**
>
> 용도: 클래스는 객체를 **생성하는데 사용**



##### [객체&인스턴스]

클래스→인스턴스(객체)

> 위 과정을 '인스턴스화' 라고 한다.



**[인스턴스의 생성과 사용]**

***'인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다'***

```java
class Car{
  //Car라는 클래스를 만들었다.
  //Car 의 속성 
  String color;
  int number;
  
  //Car의 메서드
  void power(){
    System.out.println("power")
  }
}
class CarTest{
  public status void main(String args[]){
      Car c; //클래스의 '객체'를 참조하기위한 '참조변수(c)'를 선언	
			c = new Car(); //클래스의 객체를 생성 후(인스턴스화), 겍체의 '주소'를 참조변수에 저장
    	c.color="red";
    	c.number=1234;
    	c.power();
  }
}


```

> `Car c;` 
>
> > 위 구문을 통해 메모리에 c를 위한 공간이 마련되지만 아직 아무 내용이 없다
>
> `c = new Car();`
>
> > 위 구문을 통해 메모리 공간에 Car 클래스의 인스턴스가 메모리 빈공간에 생성되고,
> >
> > 참조변수 c에는 이 메모리의 **'주소값'** 이 저장된다.
>
> `c.color="red"` , `c.number=1234;`
>
> > 참조변수 c에 저장되어있는 주소에 있는 인스턴스 멤버변수 color에 "red"를 저장한다.
> >
> > 참조변수 c에 저장되어있는 주소에 있는 인스턴스 멤버변수 number에 1234 를 저장한다.
>
> `c.power`
>
> > 참조변수 c에 저장되어있는 주소에 있는 메서드 power을 호출한다. (메서드를 실행한다.)



```java
Car c1=new Car();
Car c2=new Car();

c1.color="blue";
c2.color="red";

System.out.println(c1.color); //blue
System.out.println(c2.color); //red
```

>위 상황에서는 `c1`, `c2`에 각각의 인스턴스가 메모리 빈 공간에 생성되고, 각각은 각각의 메모리의 주소값이 저장되어 서로 다른 인스턴스를 참고하여 독립적으로 존재한다.

```java
c1=c2
```

> 이때 위 코드를 작성하면 `c2`에 저장되어있던 주소값을 `c1`에 저장하게된다.
>
> 이 경우 `c1`은 원래 참조하던 인스턴스의 정보를 잃고 `c2`가 참고중인 인스턴스를 같이 참조하게 된다.
>
> > '둘 이상의 참조변수' 가 '하나의 인스턴스' 를 참조하는 것: **가능**
> >
> > '하나의 참조변수'가 '둘 이상의 인스턴스' 를 참조하는 것: **불가능**





**[객체 배열]**

많은 수의 객체를 다뤄야 할 때? 객체 배열을 이용하면 수월!

```java
Car[] carArr = new Car[3]; //길이가 3인 Car타입의 참조변수 배열

//carArr[0]=new Car();
//carArr[1]=new Car();
//carArr[2]=new Car(); 
//         or
//Car[] carArr={new Car(), new Car(), new Car()};
//도 되지만
 
for(int i=0,i<carArr.length;i++){
  carArr[i]=new Car();
} //위 코드가 더 많은 내용을 처리할 수 있음


```



**[클래스의 또 다른 정의]**

>1. 설계도
>2. 데이터+함수
>3. 사용자 정의 타입 (원하는 타입을 직접 만들 수 있다.)

*(1~4는 데이터 저장형태의 발전순서)*

1. 변수

> 하나의 데이터를 저장할 수 있는 공간

2. 배열

> 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간

3. 구조체

> 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간

4. 클래스

> 데이터와 함수의 결합(구조체+함수)



**'자바와 같은 객체지향언어에서는 변수(데이터)와 함수를 하나의 클래스에 정의,**

​                      **서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있다!'**



***



### 변수와 메서드

**[변수의 종류]**


|  변슈의 종류  |        선언 위치        |          생성시기           |
| :-----------: | :---------------------: | :-------------------------: |
|  클래스 변수  |       클래스 영역       | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수 |       클래스 영역       |  인스턴스가 생성되었을 때   |
|   지역 변수   | 클래스 영역 이외의 영역 | 변수 선언문이 수행되었을 때 |

```java
class Card{
  String kind;
  int number;  //인스턴스 변수
  
  static int width=100;
  static int heigh=200; //클래스 변수 (앞에 static을 붙여 선언)
}
```

> 인스턴스 변수: 인스턴스마다 독립적인 저장공간을 가짐
>
> ​           (객체는 인스턴스의 변수 묶음 이라고 봐도 무방!)
>
> 클래스 변수: 모든 인스턴스가 공통된 저장공간을 가짐 
>
> ​          (한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우 클래스 변수를 선언)



```java
class testCard{
  Card c1=new Card();
  Card c2=new Card();
  
  c1.kind="Heart";
  c1.number=7;
  c2.kind="Spade";
  c2.number=3;
  
  System.out.println(c1.number); // 7
  System.out.println(c2.number); // 3
  
  c1.heigh=700;
  
  System.out.println(c1.heigh); //700
  System.out.println(c2.heigh); //700
  System.out.println(Card.heigh); //700
}
```

> 카드마다 다른 속성인 `kind`와 `number`는 인스턴스 변수로 선언 된 반면,
>
> 모든 카드의 크기는 동일해야 하므로 `width`와 `heigh`은 클래스 변수로 선언되어있음
>
> 이 경우 카드 하나의 `heigh`만 변경하여도 클래스 내의 모든 인스턴스의 `heigh`이 변경됨
>
> > 클래스 변수를 사용할 땐 '클래스이름.클래스변수' 로 사용할 수 있고, **주로 이렇게 사용**



**[메서드]**

> 함수와 비슷하지만 입력값, 출력값 중 하나가 없거나 둘 다 없을 수 있다.
>
> **최소의 의미있는 작업 단위로 묶어야 유지보수, 재사용성 측면에서 유리함**

장점

1. 높은 재사용성

> 한번 만들어 놓으면 호출하며 계속 사용 가능

2. 중복된 코드의 제거

> 반복되는 문장들을 메서드로 만들어 묶어두면 계속해서 문장들을 작성 할 필요 없이 메서드만 호출하여 실행하면 된다.

3. 프로그램의 구조화

> 큰 규모의 프로그램에서는 문장들을 작업단위로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화 시키는 것이 필수적
>
> > (ex) 처음에 프로그램을 설계할 때 내용이 없는 메서드를 작업단위로 만들어 놓고, 하나씩 완성해 나가는 방법



```java
int add (int x,int y){  //[반환 타입] [메서드명] [매개변수(지역변수임) 선언]
  return x+y;  //결과를 반환
}
```

> `int` 
>
> > 메서드의 반환 타입. 위 경우 int+int 를 통해 int를 retrun하므로 int로 반환받는다.
> >
> > return 타입이 없는 경우 `void` 로 작성한다.
>
> `add`
>
> > 메서드의 이름. 주로 동사인 경우가 많으며 메서드가 어떤 일을 하는지 함축적이면서 의미있는 이름으로 짓는것이 좋다.
>
> `(int x, int y)`
>
> > 매개변수를 받지 않을 때는 `()` 로 작성하며 두개 이상의 매개변수를 선언할 때는 각 매개변수마다 변수의 타입을 적는다. (입력 받을 값의 개수가 많다면 배열이나 참조변수도 가능)



```java
public class test{
	public static void main(String[] args) {
		Calculate a1= new Calculate();
		int sum=a1.add(1,2);
		System.out.println(sum); //3
	}	
}

class Calculate{
  int add (int x,int y){  
  	return x+y; 
	}
}
```

> a1.add(1,2)
>
> > `참조변수` . `메서드이름`으로 메서드를 실행



**[메서드: 매개변수]**

> 기본형 매개변수: read only
>
> 참조형 매개변수: read & write

```java
public class test{
	public static void main(String[] args) {
		Data d= new Data();
		d.x=1;
		System.out.println(d.x); // 1
		
		change1(d.x); //1000
		System.out.println(d.x); // 1
		
		change2(d); //1000
		System.out.println(d.x); //1000
		}
		
		static void change1(int x) {
			x=1000;
			System.out.println(x);
		}
		
		static void change2(Data d) {
			d.x=1000;
			System.out.println(d.x);
		}
	}	


class Data{
	int x;
}
```

> `change1` : 기본형 매개변수(int) 를 받아 수행하는 메소드
>
> `change2` : 참조형 매개변수(Data) 를 받아 수행하는 메소드
>
> > `change1` 에서 x=1000은 메소드 안에 있는 매개변수에 1000을 대입하는 것이다. 
> >
> > `change2` 에서 Data를 매개변수로 받는다는 것은 'd.x에 저장된 주소값'을 받아온 것이기 때문에 읽는 것은 물론 변경하는 것도 가능하다



**[메서드: 참조형 반환타입]**

> 반환타입이 참조형이라는 것은 
>
> 메서드가 *<u>**'객체의 주소를 반환한다는 것'**</u>*을 의미한다



**[static]**

1. 클래스를 설계할 때, 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다
2. static변수(클래스 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. static메서드(클래스 메서드)에서는 인스턴스 변수를 사용할 수 없다.

4. 매서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

⚡︎ 주의 ⚡︎

static메서드 에서는 '인스턴스 메서드 or 인스턴스 변수'를 호출할 수 없다!

(아직 static에 대해 깊은 이해가 부족하다,, 발전하는 대로 업데이트 예정..!)



***

### 오버로딩

> 변수와 마찬가지로 메서드도 같은 클래스 내에서 서로 구별될 수 있어야하기 때문에 서로 다른 이름을 가져야 한다.
>
> 이때 메서드의 매개변수의 타입이나 개수가 다르면 같은 메서드 이름으로 여러개의 메서드를 만드는 것이 가능한데 이것이 '메서드 오버로딩' 이다.

> 조건
>
> 1. 메서드의 이름이 같아야한다.
> 2. 매개변수의 개수 or 타입이 달라야 한다.

```java
int add(int a, int b){
  return a+b;
}
long add()(int a, int b){
  return (long)(a+b);
}
```

> 위 경우는 반환타입만 다르고 매개변수의 개수, 타입이 모두 같다. 이런경우는 오버로딩 x

```java
int add(int a, int b){
  return a+b;
}
long add(long a, long b){
  return a+b
}
```

> 위 경우는 매개변수의 타입이 다르므로 오버로딩 o



***

### 생성자

> 생성자 : 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'
>
> 주로 인스턴스 변수 초기화에 이용되며, 인스턴스 생성시에 실행되어야 할 작업을 위해 사용
>
> 조건
>
> 1. 생성자의 이름은 클래스의 이름과 같아야한다.
> 2. 생성자는 리턴 값이 없다. (따라서 생성자도 메서드이지만 void 생략 가능!)

(이해를 돕기위한 예시)

`Car c = new Car();`

1. `new` 라는 연산자에 의해 메모리(heap)에 Car클래스의 인스턴스가 생성됨
2. 생성자 `Car()` 가 호출되어 수행
3. 연산자 `new` 의 결과로, 생성된 Car 인스턴스의 주소가 c에 저장됨



**[기본생성자]**

클래스에 기본생성자 ( `[클래스이름]()` ) 가 없을 때는 컴파일러에 의해 추가됨!



**[매개변수가 있는 생성자]**

```java
class Car{
  String color;
  String type;
  int number;
  
  Car(){} //기본생성자
  Car(String c, String t, int n){
    color=c;
    type=t;
    number=n;
  } //매개변수가 있는 생성자
}
```

```java
class carTest{
  public static void main(String[] args) {
    Car c1 = new Car(); //기본생성자 호출
    c1.color="w";
    c1.type="t";
    c1.number=3;
    
    Car c2 = new Car("w","t",3);
  }
}
```

> `carTest` 의 c1과 c2에는 같은 정보가 들어있다



**[this]**

```java
class Car{
  String color;
  String type;
  int number;
  
  Car(){
    //color="w";
    //type="t";
    //number=3;
    this("w","t",3)
  }   //--1
  Car(String color, String type, int number){
    this.color=color;
    this.type=type;
    this.number=number;
  }   // --2
}
```

> 1. `this()` 을 이용하면 위 예시와 같이 더 간단하게 표현이 가능하다
> 2. 클래스를 위처럼 바꾸면 더 직관적으로 코드를 이해할 수 있다.



***



### 변수의 초기화

> 변수를 선언하고 처음으로 값을 저장하는 것
>
> 가능하면 선언과 동시에 적절한 값으로 초기화 하는 것이 바람직함.
>
> > 멤버변수: 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어짐
> >
> > 지역변수: 사용하기전에 **'반드시'** 초기화를 해야함

|      자료형      |   기본값    |
| :--------------: | :---------: |
|     boolean      |    false    |
|       char       |   '\u000'   |
| byte, short, int |      0      |
|       long       |     0L      |
|      float       |    0.0f     |
|      double      | 0.0d or 0.0 |
|   참조형 변수    |    null     |

> 타입별 기본값을 모아놓은 표



**[명시적 초기화]**

> 변수를 선언과 동시에 초기화 하는 것

```java
class Car{
  int door=4;             // 기본형 변수의 초기화
  Engine e=new Engine();  // 참조형 변수의 초기화
}
```



**[초기화 블럭]**

> 명시적 초기화가 직관적이고 간단하지만, 더 복잡한 초기화를 해야할 때 **'초기화 블럭'**을 이용한다.
>
> > 클래스 초기화 블럭 : 클래스변수의 복잡한 초기화에 사용
> >
> > 인스턴스 초기화 블럭: 인스턴스변수의 복잡한 초기화에 사용

```java
class InitBlock{
  static{
    // 클래스 초기화 블럭
  }
  
  {
    //인스턴스 초기화 블럭
  }
  
  // ...
}
```

> 클래스 초기화블럭: 메모리에 처음 로딩될 때 한번만 수행됨
>
> 인스턴스 초기화블럭: 생성자와 같이 인스턴스를 생성할 때 마다 수행 
>
> > 생성자보다 초기화블럭이 먼저 실행됨
> >
> > 인스턴스변수의 초기화는 주로 생성자를 사용
> >
> > 모든 생성자에서 공통으로 수행돼야 하는 코드를 넣는데 사용

```java
class Car{
  String color;
  int door;
  int number;
  Car(){
    color="black";
    door=4;
  }
  Car(int number){
    color="black";
    door=4;
    this.number=number;
  }
}
```

```java
class Car{
  String color;
  int door;
  int number;
  {
    color="black";
    door=4;
  }
  Car(){}
  Car(int number){
    this.number=number;
  }
}
```

>코드를 위와같이 작성하면 코드의 중복을 줄여 간결해지며,
>
>코드의 신뢰성을 높이고, 오류 발생가능성을 줄여줌



**[멤버변수의 초기화 시기와 순서]**

시점

> 클래스변수: 클래스가 처음 로딩될 때 **'1번'**
>
> 인스턴스변수: **'인스턴스가 생성될 때 마다'** 각 인스턴스별로

순서

> 클래스변수: 기본값 → 명시적 초기화 → 클래스 초기화 블럭
>
> 인스턴스변수: 기본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자

```java
class InitTest{
  static int cv=1; //클래스 변수의 명시적 초기화
  int iv=1; //인스턴스 변수의 명시적 초기화
  
  static {	cv=2;	} //클래스 초기화 블럭
  
  {	iv=2;	} //인스턴스 초기화 블럭
  
  initTest(){ // 생성자
    iv=3;
  }
}
```

> 메모리
>
> 1. cv=0 (클래스 변수의 기본값)
> 2. cv=1 (클래스 변수의 명시적 초기화)
> 3. cv=2 (클래스 초기화 블럭)
> 4. cv=2 | iv=0 (인스턴스 변수의 기본값)
> 5. cv=2 | iv=1 (인스턴스 변수의 명시적 초기화)
> 6. cv=2 | iv=2 (인스턴스 초기화 블럭)
> 7. cv=2 | iv=3 (생성자)
>
> > 클래스변수는 항상 인스턴스변수보다 먼저 생성&초기화 된다.

> 클래스변수를 명시적 초기화 하는 경우
>
> > 인스턴스가 생성될 때 마다 초기화되지 않고 값을 누적하거나 유지해야할 때
