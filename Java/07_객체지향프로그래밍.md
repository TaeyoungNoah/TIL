# 객체지향프로그래밍

### 객체지향언어

##### [장점]

1. 코드의 재사용성이 높다

> 새로운 코드 작성시 기존 코드를 이용하여 쉽게 작성 가능

2. 코드의 관리가 용이하다.

> 코드 변경시 코드의 관계를 이용하여 쉽게 가능

3. 신뢰성이 높은 프로그래밍을 가능하게 한다.

> 제어자와 메서드를 이용하여 데이터 보호&올바른 값을 유지
>
> 코드의 중복을 제거하여 코드의 불일치로 인한 오작동 방지



***



### 클래스&객체

##### [클래스]

> 정의: 클래스란 객체를 **정의해 놓은 것**
>
> 용도: 클래스는 객체를 **생성하는데 사용**



##### [객체&인스턴스]

클래스→인스턴스(객체)

> 위 과정을 '인스턴스화' 라고 한다.



**[인스턴스의 생성과 사용]**

***'인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다'***

```java
class Car{
  //Car라는 클래스를 만들었다.
  //Car 의 속성 
  String color;
  int number;
  
  //Car의 메서드
  void power(){
    System.out.println("power")
  }
}
class CarTest{
  public status void main(String args[]){
      Car c; //클래스의 '객체'를 참조하기위한 '참조변수(c)'를 선언	
			c = new Car(); //클래스의 객체를 생성 후, 겍체의 '주소'를 참조변수에 저장
    	c.color="red";
    	c.number=1234;
    	c.power();
  }
}


```

> Car c; 
>
> > 위 구문을 통해 메모리에 c를 위한 공간이 마련되지만 아직 아무 내용이 없다
>
> c = new Car();
>
> > 위 구문을 통해 메모리 공간에 Car 클래스의 인스턴스가 메모리 빈공간에 생성되고,
> >
> > 참조변수 c에는 이 메모리의 **'주소값'** 이 저장된다.
>
> c.color="red" , c.number=1234;
>
> > 참조변수 c에 저장되어있는 주소에 있는 인스턴스 멤버변수 color에 "red"를 저장한다.
> >
> > 참조변수 c에 저장되어있는 주소에 있는 인스턴스 멤버변수 number에 1234 를 저장한다.
>
> c.power
>
> > 참조변수 c에 저장되어있는 주소에 있는 메서드 power을 호출한다. (메서드를 실행한다.)



```java
Car c1=new Car();
Car c2=new Car();

c1.color="blue";
c2.color="red";

System.out.println(c1.color); //blue
System.out.println(c2.color); //red
```

>위 상황에서는 c1, c2에 각각의 인스턴스가 메모리 빈 공간에 생성되고, 각각은 각각의 메모리의 주소값이 저장되어 서로 다른 인스턴스를 참고하여 독립적으로 존재한다.

```java
c1=c2
```

> 이때 위 코드를 작성하면 c2에 저장되어있던 주소값을 c1에 저장하게된다.
>
> 이 경우 c1은 원래 참조하던 인스턴스의 정보를 잃고 c2가 참고중인 인스턴스를 같이 참조하게 된다.
>
> > '둘 이상의 참조변수' 가 '하나의 인스턴스' 를 참조하는 것: **가능**
> >
> > '하나의 참조변수'가 '둘 이상의 인스턴스' 를 참조하는 것: **불가능**





**[객체 배열]**

많은 수의 객체를 다뤄야 할 때? 객체 배열을 이용하면 수월!

```java
Car[] carArr = new Car[3]; //길이가 3인 Car타입의 참조변수 배열

//carArr[0]=new Car();
//carArr[1]=new Car();
//carArr[2]=new Car(); 
//         or
//Car[] carArr={new Car(), new Car(), new Car()};
//도 되지만
 
for(int i=0,i<carArr.length;i++){
  carArr[i]=new Car();
} //위 코드가 더 많은 내용을 처리할 수 있음


```



**[클래스의 또 다른 정의]**

*(1~4는 데이터 저장형태의 발전순서)*

1. 변수

> 하나의 데이터를 저장할 수 있는 공간

2. 배열

> 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간

3. 구조체

> 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간

4. 클래스

> 데이터와 함수의 결합(구조체+함수)



**'자바와 같은 객체지향언어에서는 변수(데이터)와 함수를 하나의 클래스에 정의,**

​                      **서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있다!'**



***



### 변수와 메서드

**[변수의 종류]**


|  변슈의 종류  |        선언 위치        |          생성시기           |
| :-----------: | :---------------------: | :-------------------------: |
|  클래스 변수  |       클래스 영역       | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수 |       클래스 영역       |  인스턴스가 생성되었을 때   |
|   지역 변수   | 클래스 영역 이외의 영역 | 변수 선언문이 수행되었을 때 |

```java
class Card{
  String kind;
  int number;  //인스턴스 변수
  
  static int width=100;
  static int heigh=200; //클래스 변수 (앞에 static을 붙여 선언)
}
```

> 인스턴스 변수: 인스턴스마다 독립적인 저장공간을 가짐
>
> 클래스 변수: 모든 인스턴스가 공통된 저장공간을 가짐 
>
> ​          (한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우 클래스 변수를 선언)



```java
class testCard{
  Card c1=new Card();
  Card c2=new Card();
  
  c1.kind="Heart";
  c1.number=7;
  c2.kind="Spade";
  c2.number=3;
  
  System.out.println(c1.number); // 7
  System.out.println(c2.number); // 3
  
  c1.heigh=700;
  
  System.out.println(c1.heigh); //700
  System.out.println(c2.heigh); //700
  System.out.println(Card.heigh); //700
}
```

> 카드마다 다른 속성인 kind와 number는 인스턴스 변수로 선언 된 반면,
>
> 모든 카드의 크기는 동일해야 하므로 width와 heigh은 클래스 변수로 선언되어있음
>
> 이 경우 카드 하나의 heigh만 변경하여도 클래스 내의 모든 인스턴스의 heigh이 변경됨
>
> > 클래스 변수를 사용할 땐 '클래스이름.클래스변수' 로 사용할 수 있고, 주로 이렇게 사용







